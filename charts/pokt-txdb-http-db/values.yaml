# Default values for pokt-txdb-http-db.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 1

image:
  repository: pocketfoundation/pocket-http-db
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: "master"

imagePullSecrets:
  []
  # - name: "regcred"
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: "pokt-txdb-http-db"

podAnnotations: {}

podSecurityContext:
  {}
  # fsGroup: 2000

securityContext:
  {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

service:
  type: ClusterIP
  port: 80

probes:
  enabled: false

ingress:
  enabled: false
  className: ""
  annotations: {}
  hosts:
    - host: mydomain.com
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls:
    - secretName: mydomain-com-tls
      hosts:
        - mydomain.com

resources:
  {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

autoscaling:
  enabled: false
  minReplicas: 3
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80

nodeSelector: {}

tolerations: []

affinity: {}

externalSecrets:
  enabled: false
  # external secret key
  # key: "some/path/secret"
  # # secret-store config
  # secretStore: "vault"
  # vault:
  #   server: "https://vault:8200"
  #   mountPath: "k8s-mount-path"
  #   namespace: "our/namespace/"
  #   serviceAccount: "portal-api"
  #   role: "my-role"
  #   path: "path/"
  #   version: "v1"

# Environment variable listing
env:
  # non sensitive variables
  normal:
    PORT: 80
    CONNECTION_STRING: "postgres://pokt:P0K7p05tgr3s8@postgres-httpdb:5432/phd?sslmode=disable"
    API_KEYS: "dummyvalue"
    CACHE_REFRESH: 180
  # sensitive variables stored in a secret
  secret:
    []
    # PHD_API_KEY: "dummyvalu3"
    # PHD_BASE_URL: "https://phd.com/"
    # PROVIDER_RPC: "dummyvalu3"
    # GODMODE_ACCOUNTS: "dummyvalu3"
    # DATABASE_ENCRYPTION_KEY: "dummyvalu3"
    # POCKET_NETWORK_CLIENT_PUB_KEY: "dummyvalu3"
    # MAX_USER_ENDPOINTS: "dummyvalu3"
    # AUDIENCE: "dummyvalu3"
    # AUTH0_ISSUER: "dummyvalu3"

postgresql:
  enabled: true
  fullnameOverride: "postgres-httpdb"
  architecture: "standalone"
  auth:
    username: "pokt"
    password: "P0K7p05tgr3s8"
    database: "phd"
  primary:
    persistence:
      enabled: false
    initdb:
      scripts:
        00_db_init_script.sql.sql: |
          -- Pay Plans
          CREATE TABLE IF NOT EXISTS pay_plans (
            id INT GENERATED ALWAYS AS IDENTITY,
            plan_type VARCHAR NOT NULL UNIQUE,
            daily_limit INT NOT NULL,
            PRIMARY KEY (plan_type)
          );

          -- Blockchains
          CREATE TABLE IF NOT EXISTS blockchains (
            id INT GENERATED ALWAYS AS IDENTITY,
            blockchain_id VARCHAR NOT NULL UNIQUE,
            active BOOLEAN,
            altruist VARCHAR,
            blockchain VARCHAR,
            blockchain_aliases VARCHAR[],
            chain_id VARCHAR,
            chain_id_check VARCHAR,
            description VARCHAR,
            enforce_result VARCHAR,
            log_limit_blocks INT,
            network VARCHAR,
            path VARCHAR,
            request_timeout INT,
            ticker VARCHAR,
            created_at TIMESTAMP NULL,
            updated_at TIMESTAMP NULL,
            PRIMARY KEY (blockchain_id)
          );

          CREATE TABLE IF NOT EXISTS redirects (
            id INT GENERATED ALWAYS AS IDENTITY,
            blockchain_id VARCHAR NOT NULL,
            alias VARCHAR NOT NULL,
            loadbalancer VARCHAR NOT NULL,
            domain VARCHAR NOT NULL,
            created_at TIMESTAMP NULL,
            updated_at TIMESTAMP NULL,
            UNIQUE (blockchain_id, domain),
            PRIMARY KEY (id),
            CONSTRAINT fk_blockchain
                FOREIGN KEY(blockchain_id)
                REFERENCES blockchains(blockchain_id)
          );

          CREATE TABLE IF NOT EXISTS sync_check_options (
            id INT GENERATED ALWAYS AS IDENTITY,
            blockchain_id VARCHAR NOT NULL UNIQUE,
            syncCheck VARCHAR,
            allowance INT,
            body VARCHAR,
            path VARCHAR,
            result_key VARCHAR,
            PRIMARY KEY (id),
            CONSTRAINT fk_blockchain
                FOREIGN KEY(blockchain_id)
                REFERENCES blockchains(blockchain_id)
          );

          -- Load Balancers
          CREATE TABLE IF NOT EXISTS loadbalancers (
            id INT GENERATED ALWAYS AS IDENTITY,
            lb_id VARCHAR NOT NULL UNIQUE,
            user_id VARCHAR,
            name VARCHAR,
            request_timeout INT,
            gigastake BOOLEAN,
            gigastake_redirect BOOLEAN,
            created_at TIMESTAMP NULL,
            updated_at TIMESTAMP NULL,
            PRIMARY KEY (id)
          );

          CREATE TABLE IF NOT EXISTS stickiness_options (
            id INT GENERATED ALWAYS AS IDENTITY,
            lb_id VARCHAR NOT NULL UNIQUE,
            duration TEXT,
            sticky_max INT,
            stickiness BOOLEAN,
            origins VARCHAR[],
            PRIMARY KEY (id),
            CONSTRAINT fk_lb
                FOREIGN KEY(lb_id)
                REFERENCES loadbalancers(lb_id)
          );

          -- Applications
          CREATE TABLE IF NOT EXISTS applications (
            id INT GENERATED ALWAYS AS IDENTITY,
            application_id VARCHAR NOT NULL UNIQUE,
            contact_email VARCHAR,
            description TEXT,
            name VARCHAR,
            status VARCHAR,
            -- TODO remove deprecated field once database updated
            pay_plan_type VARCHAR,
            owner VARCHAR,
            url VARCHAR,
            user_id VARCHAR,
            dummy BOOLEAN,
            first_date_surpassed TIMESTAMP NULL,
            created_at TIMESTAMP NULL,
            updated_at TIMESTAMP NULL,
            PRIMARY KEY (application_id)
          );

          CREATE TABLE IF NOT EXISTS app_limits (
            id INT GENERATED ALWAYS AS IDENTITY,
            application_id VARCHAR NOT NULL UNIQUE,
            pay_plan VARCHAR NOT NULL,
            custom_limit INT NULL,
            PRIMARY KEY (id),
            CONSTRAINT fk_application
                FOREIGN KEY(application_id)
                REFERENCES applications(application_id),
            CONSTRAINT fk_pay_plan
                FOREIGN KEY(pay_plan)
                REFERENCES pay_plans(plan_type)
          );

          CREATE TABLE IF NOT EXISTS gateway_aat (
            id INT GENERATED ALWAYS AS IDENTITY,
            application_id VARCHAR NOT NULL UNIQUE,
            address VARCHAR NOT NULL,
            public_key VARCHAR NOT NULL,
            private_key VARCHAR,
            signature VARCHAR NOT NULL,
            client_public_key VARCHAR NOT NULL,
            version VARCHAR,
            PRIMARY KEY (id),
            CONSTRAINT fk_application
                FOREIGN KEY(application_id)
                REFERENCES applications(application_id)
          );

          CREATE TABLE IF NOT EXISTS gateway_settings (
            id INT GENERATED ALWAYS AS IDENTITY,
            application_id VARCHAR NOT NULL UNIQUE,
            secret_key VARCHAR,
            secret_key_required BOOLEAN,
            whitelist_blockchains VARCHAR[],
            whitelist_contracts VARCHAR,
            whitelist_methods VARCHAR,
            whitelist_origins VARCHAR[],
            whitelist_user_agents VARCHAR[],
            PRIMARY KEY (id),
            CONSTRAINT fk_application
                FOREIGN KEY(application_id)
                REFERENCES applications(application_id)
          );

          CREATE TABLE IF NOT EXISTS notification_settings (
            id INT GENERATED ALWAYS AS IDENTITY,
            application_id VARCHAR NOT NULL UNIQUE,
            signed_up BOOLEAN,
            on_quarter BOOLEAN,
            on_half BOOLEAN,
            on_three_quarters BOOLEAN,
            on_full BOOLEAN,
            PRIMARY KEY (id),
            CONSTRAINT fk_application
                FOREIGN KEY(application_id)
                REFERENCES applications(application_id)
          );

          -- Load Balancer-Apps Join Table
          CREATE TABLE IF NOT EXISTS lb_apps (
            id INT GENERATED ALWAYS AS IDENTITY,
            lb_id VARCHAR NOT NULL,
            app_id VARCHAR NOT NULL,
            UNIQUE(lb_id, app_id),
            PRIMARY KEY (id),
            CONSTRAINT fk_lb
                FOREIGN KEY(lb_id)
                REFERENCES loadbalancers(lb_id),
            CONSTRAINT fk_app
                FOREIGN KEY(app_id)
                REFERENCES applications(application_id)
          );

          -- Insert Rows
          INSERT INTO pay_plans (plan_type, daily_limit)
          VALUES
              ('FREETIER_V0', 250000),
              ('PAY_AS_YOU_GO_V0', 0),
              ('ENTERPRISE', 0),
              ('TEST_PLAN_V0', 100),
              ('TEST_PLAN_10K', 10000),
              ('TEST_PLAN_90K', 90000);

          CREATE OR REPLACE FUNCTION notify_event() RETURNS TRIGGER AS $$

              DECLARE
                  data json;
                  notification json;

              BEGIN

                  -- Convert the old or new row to JSON, based on the kind of action.
                  -- Action = DELETE?             -> OLD row
                  -- Action = INSERT or UPDATE?   -> NEW row
                  IF (TG_OP = 'DELETE') THEN
                      data = row_to_json(OLD);
                  ELSE
                      data = row_to_json(NEW);
                  END IF;

                  -- Contruct the notification as a JSON string.
                  notification = json_build_object(
                                    'table',TG_TABLE_NAME,
                                    'action', TG_OP,
                                    'data', data);


                  -- Execute pg_notify(channel, notification)
                  PERFORM pg_notify('events',notification::text);

                  -- Result is ignored since this is an AFTER trigger
                  RETURN NULL;
              END;

          $$ LANGUAGE plpgsql;

          CREATE TRIGGER loadbalancer_notify_event
          AFTER INSERT OR UPDATE ON loadbalancers
              FOR EACH ROW EXECUTE PROCEDURE notify_event();
          CREATE TRIGGER stickiness_options_notify_event
          AFTER INSERT OR UPDATE ON stickiness_options
              FOR EACH ROW EXECUTE PROCEDURE notify_event();

          CREATE TRIGGER lb_apps_notify_event
          AFTER INSERT ON lb_apps
              FOR EACH ROW EXECUTE PROCEDURE notify_event();

          CREATE TRIGGER application_notify_event
          AFTER INSERT OR UPDATE ON applications
              FOR EACH ROW EXECUTE PROCEDURE notify_event();
          CREATE TRIGGER app_limits_notify_event
          AFTER INSERT OR UPDATE ON app_limits
              FOR EACH ROW EXECUTE PROCEDURE notify_event();
          CREATE TRIGGER gateway_aat_notify_event
          AFTER INSERT ON gateway_aat
              FOR EACH ROW EXECUTE PROCEDURE notify_event();
          CREATE TRIGGER gateway_settings_notify_event
          AFTER INSERT OR UPDATE ON gateway_settings
              FOR EACH ROW EXECUTE PROCEDURE notify_event();
          CREATE TRIGGER notification_settings_notify_event
          AFTER INSERT OR UPDATE ON notification_settings
              FOR EACH ROW EXECUTE PROCEDURE notify_event();

          CREATE TRIGGER blockchain_notify_event
          AFTER INSERT OR UPDATE ON blockchains
              FOR EACH ROW EXECUTE PROCEDURE notify_event();
          CREATE TRIGGER redirect_notify_event
          AFTER INSERT ON redirects
              FOR EACH ROW EXECUTE PROCEDURE notify_event();
          CREATE TRIGGER sync_check_options_notify_event
          AFTER INSERT ON sync_check_options
              FOR EACH ROW EXECUTE PROCEDURE notify_event();
